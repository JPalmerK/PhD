sort(rep(c(5,10,15),2))
ggplot(BootstrapCoefs2_invlogit, aes(x=ShoreDist, y=vals)) +
geom_boxplot() +
ggtitle(paste('Partial Plot of ShoreDist ', as.character(unique(data_sub$GroupId))))
# Get the Partial Residuals for each plot Group ID
# Plot Storage
p=list()
Sd_P=list()
for(ii in 1:10){
data_sub=subset(OccTable_daily_wDetections, GroupId==unique(OccTable$GroupId)[ii])
data_sub$DummyDate=as.Date(data_sub$JulienDay, origin=as.Date("2013-01-01"))
mod=modlist[[ii]]
JdateForPlotting<- seq(min(data_sub$JulienDay), max(data_sub$JulienDay))
YearsForPlotting=unique(data_sub$Year)
ShoreDistForPlotting=unique(data_sub$ShoreDist)
# Trim Julien Date to be divisible by 10
if (length(JdateForPlotting) %% 10>0){
JdateForPlotting=JdateForPlotting[-runif(length(JdateForPlotting) %% 10, min=1, max=length(JdateForPlotting))]
}
BootstrapParameters<-mvrnorm(10000, coef(mod), summary(mod)$cov.unscaled)
#######################################################
# Julien Date Smoothes #
#######################################################
# Get the smoothed index terms
if(ii==7){
BS_idx=c(2:4)
}else{BS_idx=which(grepl("bs", colnames(BootstrapParameters)))}
test<- glm(formula(mod),family=binomial, data=data_sub)
x1<-model.matrix(test)[,BS_idx]%*%coef(mod)[BS_idx]
BootstrapCoefs<- BootstrapParameters[,c(1, BS_idx)]
Basis<- cbind(rep(1,10), bs(JdateForPlotting))
RealFit<- Basis%*%coef(mod)[c(1, BS_idx)]
RealFitCenter1<- RealFit-mean(x1)-coef(mod)[1]
BootstrapFits<- Basis%*%t(BootstrapCoefs)
quant.func<- function(x){quantile(x, probs=c(0.025,0.975))}
cis<-apply(BootstrapFits, 1, quant.func)
MinimumYlim1<- min(cis-mean(x1)-coef(mod)[1])
MaximumYlim1<- max(cis-mean(x1)-coef(mod)[1])
cil1<-cis[1,]-mean(x1)-coef(mod)[1]
ciu1<-cis[2,]-mean(x1)-coef(mod)[1]
fitdf=data.frame(x=JdateForPlotting, y=inv.logit(RealFitCenter1), LCI=inv.logit(cil1), UCI=inv.logit(ciu1))
fitdf$DummyDate=as.Date(JdateForPlotting, origin=as.Date("2013-01-01"))
p[[ii]]=ggplot(data=fitdf) +
geom_line(aes(x=DummyDate, y=y)) +
geom_ribbon(aes(x=DummyDate, ymin=LCI, ymax=UCI), alpha=.3) +
geom_rug(data=subset(data_sub, OccAll==1),
aes(x=DummyDate, y=OccAll*.3, colour= ShoreDist),
sides='t', alpha=.8) +
geom_rug(data=subset(data_sub, OccAll==0),
aes(x=DummyDate, y=OccAll, colour= ShoreDist),
sides='b', alpha=.8) +
xlab('Julien Day') +
ylab('Detection Probability') +
ggtitle(paste('Partial Plot of Julien Day ', as.character(unique(data_sub$GroupId))))
rm(data_sub, mod, JdateForPlotting, x1, test, BootstrapCoefs, Basis, BootstrapFits, BootstrapParameters)
#######################################################
# Shore Dist Factors #
#######################################################
sd.func<- function(x){sd(x)}
SD_idx=which(grepl("Shore", colnames(BootstrapParameters)))
x2<-model.matrix(test)[,SD_idx]%*%coef(mod)[SD_idx]
BootstrapCoefs2<- BootstrapParameters[,c(1, SD_idx)]
RealFit<- coef(mod)[c(1, SD_idx)]
RealFitCenter1<- RealFit-mean(x2)-coef(mod)[1]
SDs=apply(BootstrapCoefs2, 2, sd)
sd1=RealFitCenter1-SDs
sd2=RealFitCenter1+SDs
cis=apply(BootstrapCoefs2, 2, quant.func)
MinimumYlim1<- min(cis-mean(x2)-coef(mod)[1])
MaximumYlim1<- max(cis-mean(x2)-coef(mod)[1])
cil1<-cis[1,]-mean(x2)-coef(mod)[1]
ciu1<-cis[2,]-mean(x2)-coef(mod)[1]
fitdf=data.frame(x=ShoreDistForPlotting, y=inv.logit(RealFitCenter1),
LCI=inv.logit(cil1), UCI=inv.logit(ciu1),
lsd=inv.logit(sd1), usd=inv.logit(sd2))
BootstrapCoefs2_invlogit=data.frame(vals=inv.logit(c(BootstrapCoefs2[,1],
BootstrapCoefs2[,2],
BootstrapCoefs2[,3])))
BootstrapCoefs2_invlogit$ShoreDist=as.character(sort(rep(c(5,10,15), length.out=nrow(BootstrapCoefs2_invlogit))))
Sd_P[[ii]]=ggplot(BootstrapCoefs2_invlogit, aes(x=ShoreDist, y=vals)) +
geom_boxplot() +
ggtitle(paste('Partial Plot of ShoreDist ', as.character(unique(data_sub$GroupId))))
}
ii
data_sub=subset(OccTable_daily_wDetections, GroupId==unique(OccTable$GroupId)[ii])
data_sub$DummyDate=as.Date(data_sub$JulienDay, origin=as.Date("2013-01-01"))
mod=modlist[[ii]]
JdateForPlotting<- seq(min(data_sub$JulienDay), max(data_sub$JulienDay))
YearsForPlotting=unique(data_sub$Year)
ShoreDistForPlotting=unique(data_sub$ShoreDist)
# Trim Julien Date to be divisible by 10
if (length(JdateForPlotting) %% 10>0){
JdateForPlotting=JdateForPlotting[-runif(length(JdateForPlotting) %% 10, min=1, max=length(JdateForPlotting))]
}
BootstrapParameters<-mvrnorm(10000, coef(mod), summary(mod)$cov.unscaled)
#######################################################
#######################################################
# Get the smoothed index terms
if(ii==7){
BS_idx=c(2:4)
}else{BS_idx=which(grepl("bs", colnames(BootstrapParameters)))}
test<- glm(formula(mod),family=binomial, data=data_sub)
x1<-model.matrix(test)[,BS_idx]%*%coef(mod)[BS_idx]
BootstrapCoefs<- BootstrapParameters[,c(1, BS_idx)]
Basis<- cbind(rep(1,10), bs(JdateForPlotting))
RealFit<- Basis%*%coef(mod)[c(1, BS_idx)]
RealFitCenter1<- RealFit-mean(x1)-coef(mod)[1]
BootstrapFits<- Basis%*%t(BootstrapCoefs)
quant.func<- function(x){quantile(x, probs=c(0.025,0.975))}
cis<-apply(BootstrapFits, 1, quant.func)
MinimumYlim1<- min(cis-mean(x1)-coef(mod)[1])
MaximumYlim1<- max(cis-mean(x1)-coef(mod)[1])
cil1<-cis[1,]-mean(x1)-coef(mod)[1]
ciu1<-cis[2,]-mean(x1)-coef(mod)[1]
fitdf=data.frame(x=JdateForPlotting, y=inv.logit(RealFitCenter1), LCI=inv.logit(cil1), UCI=inv.logit(ciu1))
fitdf$DummyDate=as.Date(JdateForPlotting, origin=as.Date("2013-01-01"))
p[[ii]]=ggplot(data=fitdf) +
geom_line(aes(x=DummyDate, y=y)) +
geom_ribbon(aes(x=DummyDate, ymin=LCI, ymax=UCI), alpha=.3) +
geom_rug(data=subset(data_sub, OccAll==1),
aes(x=DummyDate, y=OccAll*.3, colour= ShoreDist),
sides='t', alpha=.8) +
geom_rug(data=subset(data_sub, OccAll==0),
aes(x=DummyDate, y=OccAll, colour= ShoreDist),
sides='b', alpha=.8) +
xlab('Julien Day') +
ylab('Detection Probability') +
ggtitle(paste('Partial Plot of Julien Day ', as.character(unique(data_sub$GroupId))))
rm(data_sub, mod, JdateForPlotting, x1, test, BootstrapCoefs, Basis, BootstrapFits, BootstrapParameters)
sd.func<- function(x){sd(x)}
SD_idx=which(grepl("Shore", colnames(BootstrapParameters)))
x2<-model.matrix(test)[,SD_idx]%*%coef(mod)[SD_idx]
# Get the Partial Residuals for each plot Group ID
# Plot Storage
p=list()
Sd_P=list()
for(ii in 1:10){
data_sub=subset(OccTable_daily_wDetections, GroupId==unique(OccTable$GroupId)[ii])
data_sub$DummyDate=as.Date(data_sub$JulienDay, origin=as.Date("2013-01-01"))
mod=modlist[[ii]]
JdateForPlotting<- seq(min(data_sub$JulienDay), max(data_sub$JulienDay))
YearsForPlotting=unique(data_sub$Year)
ShoreDistForPlotting=unique(data_sub$ShoreDist)
# Trim Julien Date to be divisible by 10
if (length(JdateForPlotting) %% 10>0){
JdateForPlotting=JdateForPlotting[-runif(length(JdateForPlotting) %% 10, min=1, max=length(JdateForPlotting))]
}
BootstrapParameters<-mvrnorm(10000, coef(mod), summary(mod)$cov.unscaled)
#######################################################
# Julien Date Smoothes #
#######################################################
# Get the smoothed index terms
if(ii==7){
BS_idx=c(2:4)
}else{BS_idx=which(grepl("bs", colnames(BootstrapParameters)))}
test<- glm(formula(mod),family=binomial, data=data_sub)
x1<-model.matrix(test)[,BS_idx]%*%coef(mod)[BS_idx]
BootstrapCoefs<- BootstrapParameters[,c(1, BS_idx)]
Basis<- cbind(rep(1,10), bs(JdateForPlotting))
RealFit<- Basis%*%coef(mod)[c(1, BS_idx)]
RealFitCenter1<- RealFit-mean(x1)-coef(mod)[1]
BootstrapFits<- Basis%*%t(BootstrapCoefs)
quant.func<- function(x){quantile(x, probs=c(0.025,0.975))}
cis<-apply(BootstrapFits, 1, quant.func)
MinimumYlim1<- min(cis-mean(x1)-coef(mod)[1])
MaximumYlim1<- max(cis-mean(x1)-coef(mod)[1])
cil1<-cis[1,]-mean(x1)-coef(mod)[1]
ciu1<-cis[2,]-mean(x1)-coef(mod)[1]
fitdf=data.frame(x=JdateForPlotting, y=inv.logit(RealFitCenter1), LCI=inv.logit(cil1), UCI=inv.logit(ciu1))
fitdf$DummyDate=as.Date(JdateForPlotting, origin=as.Date("2013-01-01"))
p[[ii]]=ggplot(data=fitdf) +
geom_line(aes(x=DummyDate, y=y)) +
geom_ribbon(aes(x=DummyDate, ymin=LCI, ymax=UCI), alpha=.3) +
geom_rug(data=subset(data_sub, OccAll==1),
aes(x=DummyDate, y=OccAll*.3, colour= ShoreDist),
sides='t', alpha=.8) +
geom_rug(data=subset(data_sub, OccAll==0),
aes(x=DummyDate, y=OccAll, colour= ShoreDist),
sides='b', alpha=.8) +
xlab('Julien Day') +
ylab('Detection Probability') +
ggtitle(paste('Partial Plot of Julien Day ', as.character(unique(data_sub$GroupId))))
#######################################################
# Shore Dist Factors #
#######################################################
sd.func<- function(x){sd(x)}
SD_idx=which(grepl("Shore", colnames(BootstrapParameters)))
x2<-model.matrix(test)[,SD_idx]%*%coef(mod)[SD_idx]
BootstrapCoefs2<- BootstrapParameters[,c(1, SD_idx)]
RealFit<- coef(mod)[c(1, SD_idx)]
RealFitCenter1<- RealFit-mean(x2)-coef(mod)[1]
SDs=apply(BootstrapCoefs2, 2, sd)
sd1=RealFitCenter1-SDs
sd2=RealFitCenter1+SDs
cis=apply(BootstrapCoefs2, 2, quant.func)
MinimumYlim1<- min(cis-mean(x2)-coef(mod)[1])
MaximumYlim1<- max(cis-mean(x2)-coef(mod)[1])
cil1<-cis[1,]-mean(x2)-coef(mod)[1]
ciu1<-cis[2,]-mean(x2)-coef(mod)[1]
fitdf=data.frame(x=ShoreDistForPlotting, y=inv.logit(RealFitCenter1),
LCI=inv.logit(cil1), UCI=inv.logit(ciu1),
lsd=inv.logit(sd1), usd=inv.logit(sd2))
BootstrapCoefs2_invlogit=data.frame(vals=inv.logit(c(BootstrapCoefs2[,1],
BootstrapCoefs2[,2],
BootstrapCoefs2[,3])))
BootstrapCoefs2_invlogit$ShoreDist=as.character(sort(rep(c(5,10,15), length.out=nrow(BootstrapCoefs2_invlogit))))
Sd_P[[ii]]=ggplot(BootstrapCoefs2_invlogit, aes(x=ShoreDist, y=vals)) +
geom_boxplot() +
ggtitle(paste('Partial Plot of ShoreDist ', as.character(unique(data_sub$GroupId))))
rm(data_sub, mod, JdateForPlotting, x1, test, BootstrapCoefs, Basis, BootstrapFits, BootstrapParameters)
}
data_sub=subset(OccTable_daily_wDetections, GroupId==unique(OccTable$GroupId)[ii])
data_sub$DummyDate=as.Date(data_sub$JulienDay, origin=as.Date("2013-01-01"))
mod=modlist[[ii]]
JdateForPlotting<- seq(min(data_sub$JulienDay), max(data_sub$JulienDay))
YearsForPlotting=unique(data_sub$Year)
ShoreDistForPlotting=unique(data_sub$ShoreDist)
# Trim Julien Date to be divisible by 10
if (length(JdateForPlotting) %% 10>0){
JdateForPlotting=JdateForPlotting[-runif(length(JdateForPlotting) %% 10, min=1, max=length(JdateForPlotting))]
}
BootstrapParameters<-mvrnorm(10000, coef(mod), summary(mod)$cov.unscaled)
#######################################################
# Julien Date Smoothes #
#######################################################
# Get the smoothed index terms
if(ii==7){
BS_idx=c(2:4)
}else{BS_idx=which(grepl("bs", colnames(BootstrapParameters)))}
test<- glm(formula(mod),family=binomial, data=data_sub)
x1<-model.matrix(test)[,BS_idx]%*%coef(mod)[BS_idx]
BootstrapCoefs<- BootstrapParameters[,c(1, BS_idx)]
Basis<- cbind(rep(1,10), bs(JdateForPlotting))
RealFit<- Basis%*%coef(mod)[c(1, BS_idx)]
RealFitCenter1<- RealFit-mean(x1)-coef(mod)[1]
BootstrapFits<- Basis%*%t(BootstrapCoefs)
quant.func<- function(x){quantile(x, probs=c(0.025,0.975))}
cis<-apply(BootstrapFits, 1, quant.func)
MinimumYlim1<- min(cis-mean(x1)-coef(mod)[1])
MaximumYlim1<- max(cis-mean(x1)-coef(mod)[1])
cil1<-cis[1,]-mean(x1)-coef(mod)[1]
ciu1<-cis[2,]-mean(x1)-coef(mod)[1]
fitdf=data.frame(x=JdateForPlotting, y=inv.logit(RealFitCenter1), LCI=inv.logit(cil1), UCI=inv.logit(ciu1))
fitdf$DummyDate=as.Date(JdateForPlotting, origin=as.Date("2013-01-01"))
p[[ii]]=ggplot(data=fitdf) +
geom_line(aes(x=DummyDate, y=y)) +
geom_ribbon(aes(x=DummyDate, ymin=LCI, ymax=UCI), alpha=.3) +
geom_rug(data=subset(data_sub, OccAll==1),
aes(x=DummyDate, y=OccAll*.3, colour= ShoreDist),
sides='t', alpha=.8) +
geom_rug(data=subset(data_sub, OccAll==0),
aes(x=DummyDate, y=OccAll, colour= ShoreDist),
sides='b', alpha=.8) +
xlab('Julien Day') +
ylab('Detection Probability') +
ggtitle(paste('Partial Plot of Julien Day ', as.character(unique(data_sub$GroupId))))
sd.func<- function(x){sd(x)}
SD_idx=which(grepl("Shore", colnames(BootstrapParameters)))
x2<-model.matrix(test)[,SD_idx]%*%coef(mod)[SD_idx]
SD_idx
colnames(BootstrapParameters)
length(SD_idx>1)
length(SD_idx)>1
# Plot Storage
p=list()
Sd_P=list()
for(ii in 1:10){
data_sub=subset(OccTable_daily_wDetections, GroupId==unique(OccTable$GroupId)[ii])
data_sub$DummyDate=as.Date(data_sub$JulienDay, origin=as.Date("2013-01-01"))
mod=modlist[[ii]]
JdateForPlotting<- seq(min(data_sub$JulienDay), max(data_sub$JulienDay))
YearsForPlotting=unique(data_sub$Year)
ShoreDistForPlotting=unique(data_sub$ShoreDist)
# Trim Julien Date to be divisible by 10
if (length(JdateForPlotting) %% 10>0){
JdateForPlotting=JdateForPlotting[-runif(length(JdateForPlotting) %% 10, min=1, max=length(JdateForPlotting))]
}
BootstrapParameters<-mvrnorm(10000, coef(mod), summary(mod)$cov.unscaled)
#######################################################
# Julien Date Smoothes #
#######################################################
# Get the smoothed index terms
if(ii==7){
BS_idx=c(2:4)
}else{BS_idx=which(grepl("bs", colnames(BootstrapParameters)))}
test<- glm(formula(mod),family=binomial, data=data_sub)
x1<-model.matrix(test)[,BS_idx]%*%coef(mod)[BS_idx]
BootstrapCoefs<- BootstrapParameters[,c(1, BS_idx)]
Basis<- cbind(rep(1,10), bs(JdateForPlotting))
RealFit<- Basis%*%coef(mod)[c(1, BS_idx)]
RealFitCenter1<- RealFit-mean(x1)-coef(mod)[1]
BootstrapFits<- Basis%*%t(BootstrapCoefs)
quant.func<- function(x){quantile(x, probs=c(0.025,0.975))}
cis<-apply(BootstrapFits, 1, quant.func)
MinimumYlim1<- min(cis-mean(x1)-coef(mod)[1])
MaximumYlim1<- max(cis-mean(x1)-coef(mod)[1])
cil1<-cis[1,]-mean(x1)-coef(mod)[1]
ciu1<-cis[2,]-mean(x1)-coef(mod)[1]
fitdf=data.frame(x=JdateForPlotting, y=inv.logit(RealFitCenter1), LCI=inv.logit(cil1), UCI=inv.logit(ciu1))
fitdf$DummyDate=as.Date(JdateForPlotting, origin=as.Date("2013-01-01"))
p[[ii]]=ggplot(data=fitdf) +
geom_line(aes(x=DummyDate, y=y)) +
geom_ribbon(aes(x=DummyDate, ymin=LCI, ymax=UCI), alpha=.3) +
geom_rug(data=subset(data_sub, OccAll==1),
aes(x=DummyDate, y=OccAll*.3, colour= ShoreDist),
sides='t', alpha=.8) +
geom_rug(data=subset(data_sub, OccAll==0),
aes(x=DummyDate, y=OccAll, colour= ShoreDist),
sides='b', alpha=.8) +
xlab('Julien Day') +
ylab('Detection Probability') +
ggtitle(paste('Partial Plot of Julien Day ', as.character(unique(data_sub$GroupId))))
#######################################################
# Shore Dist Factors #
#######################################################
SD_idx=which(grepl("Shore", colnames(BootstrapParameters)))
if(length(SD_idx)>1){
x2<-model.matrix(test)[,SD_idx]%*%coef(mod)[SD_idx]
BootstrapCoefs2<- BootstrapParameters[,c(1, SD_idx)]
RealFit<- coef(mod)[c(1, SD_idx)]
RealFitCenter1<- RealFit-mean(x2)-coef(mod)[1]
SDs=apply(BootstrapCoefs2, 2, sd)
sd1=RealFitCenter1-SDs
sd2=RealFitCenter1+SDs
cis=apply(BootstrapCoefs2, 2, quant.func)
MinimumYlim1<- min(cis-mean(x2)-coef(mod)[1])
MaximumYlim1<- max(cis-mean(x2)-coef(mod)[1])
cil1<-cis[1,]-mean(x2)-coef(mod)[1]
ciu1<-cis[2,]-mean(x2)-coef(mod)[1]
fitdf=data.frame(x=ShoreDistForPlotting, y=inv.logit(RealFitCenter1),
LCI=inv.logit(cil1), UCI=inv.logit(ciu1),
lsd=inv.logit(sd1), usd=inv.logit(sd2))
BootstrapCoefs2_invlogit=data.frame(vals=inv.logit(c(BootstrapCoefs2[,1],
BootstrapCoefs2[,2],
BootstrapCoefs2[,3])))
BootstrapCoefs2_invlogit$ShoreDist=as.character(sort(rep(c(5,10,15), length.out=nrow(BootstrapCoefs2_invlogit))))
Sd_P[[ii]]=ggplot(BootstrapCoefs2_invlogit, aes(x=ShoreDist, y=vals)) +
geom_boxplot() +
ggtitle(paste('Partial Plot of ShoreDist ', as.character(unique(data_sub$GroupId))))}
rm(data_sub, mod, JdateForPlotting, x1, test, BootstrapCoefs, Basis, BootstrapFits, BootstrapParameters)
}
print(Sd_P)
print(Sd_P)
colnames(BootstrapParameters)
data_sub=subset(OccTable_daily_wDetections, GroupId==unique(OccTable$GroupId)[ii])
data_sub$DummyDate=as.Date(data_sub$JulienDay, origin=as.Date("2013-01-01"))
mod=modlist[[ii]]
JdateForPlotting<- seq(min(data_sub$JulienDay), max(data_sub$JulienDay))
YearsForPlotting=unique(data_sub$Year)
ShoreDistForPlotting=unique(data_sub$ShoreDist)
# Trim Julien Date to be divisible by 10
if (length(JdateForPlotting) %% 10>0){
JdateForPlotting=JdateForPlotting[-runif(length(JdateForPlotting) %% 10, min=1, max=length(JdateForPlotting))]
}
BootstrapParameters<-mvrnorm(10000, coef(mod), summary(mod)$cov.unscaled)
colnames(BootstrapParameters)
Yr_idx=which(grepl("Year", colnames(BootstrapParameters)))
Yr_idx
x2<-model.matrix(test)[,Yr_idx]%*%coef(mod)[Yr_idx]
BootstrapCoefs2<- BootstrapParameters[,c(1, Yr_idx)]
test<- glm(formula(mod),family=binomial, data=data_sub)
x2<-model.matrix(test)[,Yr_idx]%*%coef(mod)[Yr_idx]
BootstrapCoefs2<- BootstrapParameters[,c(1, Yr_idx)]
RealFit<- coef(mod)[c(1, Yr_idx)]
RealFitCenter1<- RealFit-mean(x2)-coef(mod)[1]
SDs=apply(BootstrapCoefs2, 2, sd)
sd1=RealFitCenter1-SDs
sd2=RealFitCenter1+SDs
cis=apply(BootstrapCoefs2, 2, quant.func)
cis
MinimumYlim1<- min(cis-mean(x2)-coef(mod)[1])
MinimumYlim1
MaximumYlim1
MinimumYlim1<- min(cis-mean(x2)-coef(mod)[1])
MaximumYlim1<- max(cis-mean(x2)-coef(mod)[1])
cil1<-cis[1,]-mean(x2)-coef(mod)[1]
ciu1<-cis[2,]-mean(x2)-coef(mod)[1]
ciu1
cil1
unique(data_sub$ShoreDist)
=unique(data_sub$Year)
YearsForPlotting
fitdf=data.frame(x=YearsForPlotting, y=inv.logit(RealFitCenter1),
LCI=inv.logit(cil1), UCI=inv.logit(ciu1),
lsd=inv.logit(sd1), usd=inv.logit(sd2))
fitdf
nocl(BootstrapCoefs2)
ncol(BootstrapCoefs2)
BootstrapCoefs2_invlogit$Year=as.character(sort(rep(YearsForPlotting, length.out=nrow(BootstrapCoefs2_invlogit))))
View(BootstrapCoefs2_invlogit)
Sd_P[[ii]]=ggplot(BootstrapCoefs2_invlogit, aes(x=Year, y=vals)) +
geom_boxplot() +
ggtitle(paste('Partial Plot of ShoreDist ', as.character(unique(data_sub$GroupId))))}
Sd_P[[ii]]=ggplot(BootstrapCoefs2_invlogit, aes(x=Year, y=vals)) +
geom_boxplot()
ggplot(BootstrapCoefs2_invlogit, aes(x=Year, y=vals)) +
geom_boxplot()
Yr_P[[ii]]=ggplot(BootstrapCoefs2_invlogit, aes(x=Year, y=vals)) +
geom_boxplot() +
ggtitle(paste('Partial Plot of ShoreDist ', as.character(unique(data_sub$GroupId))))}
ggplot(BootstrapCoefs2_invlogit, aes(x=Year, y=vals)) +
geom_boxplot() +
ggtitle(paste('Partial Plot of Years '))
ii
# Get the Partial Residuals for each plot Group ID
# Plot Storage
p=list()
Sd_P=list()
Yr_P=list()
for(ii in 1:10){
data_sub=subset(OccTable_daily_wDetections, GroupId==unique(OccTable$GroupId)[ii])
data_sub$DummyDate=as.Date(data_sub$JulienDay, origin=as.Date("2013-01-01"))
mod=modlist[[ii]]
JdateForPlotting<- seq(min(data_sub$JulienDay), max(data_sub$JulienDay))
YearsForPlotting=unique(data_sub$Year)
ShoreDistForPlotting=unique(data_sub$ShoreDist)
# Trim Julien Date to be divisible by 10
if (length(JdateForPlotting) %% 10>0){
JdateForPlotting=JdateForPlotting[-runif(length(JdateForPlotting) %% 10, min=1, max=length(JdateForPlotting))]
}
BootstrapParameters<-mvrnorm(10000, coef(mod), summary(mod)$cov.unscaled)
#######################################################
# Julien Date Smoothes #
#######################################################
# Get the smoothed index terms
if(ii==7){
BS_idx=c(2:4)
}else{BS_idx=which(grepl("bs", colnames(BootstrapParameters)))}
test<- glm(formula(mod),family=binomial, data=data_sub)
x1<-model.matrix(test)[,BS_idx]%*%coef(mod)[BS_idx]
BootstrapCoefs<- BootstrapParameters[,c(1, BS_idx)]
Basis<- cbind(rep(1,10), bs(JdateForPlotting))
RealFit<- Basis%*%coef(mod)[c(1, BS_idx)]
RealFitCenter1<- RealFit-mean(x1)-coef(mod)[1]
BootstrapFits<- Basis%*%t(BootstrapCoefs)
quant.func<- function(x){quantile(x, probs=c(0.025,0.975))}
cis<-apply(BootstrapFits, 1, quant.func)
MinimumYlim1<- min(cis-mean(x1)-coef(mod)[1])
MaximumYlim1<- max(cis-mean(x1)-coef(mod)[1])
cil1<-cis[1,]-mean(x1)-coef(mod)[1]
ciu1<-cis[2,]-mean(x1)-coef(mod)[1]
fitdf=data.frame(x=JdateForPlotting, y=inv.logit(RealFitCenter1), LCI=inv.logit(cil1), UCI=inv.logit(ciu1))
fitdf$DummyDate=as.Date(JdateForPlotting, origin=as.Date("2013-01-01"))
p[[ii]]=ggplot(data=fitdf) +
geom_line(aes(x=DummyDate, y=y)) +
geom_ribbon(aes(x=DummyDate, ymin=LCI, ymax=UCI), alpha=.3) +
geom_rug(data=subset(data_sub, OccAll==1),
aes(x=DummyDate, y=OccAll*.3, colour= ShoreDist),
sides='t', alpha=.8) +
geom_rug(data=subset(data_sub, OccAll==0),
aes(x=DummyDate, y=OccAll, colour= ShoreDist),
sides='b', alpha=.8) +
xlab('Julien Day') +
ylab('Detection Probability') +
ggtitle(paste('Partial Plot of Julien Day ', as.character(unique(data_sub$GroupId))))
#######################################################
# Shore Dist Factors #
#######################################################
SD_idx=which(grepl("Shore", colnames(BootstrapParameters)))
if(length(SD_idx)>1){
x2<-model.matrix(test)[,SD_idx]%*%coef(mod)[SD_idx]
BootstrapCoefs2<- BootstrapParameters[,c(1, SD_idx)]
RealFit<- coef(mod)[c(1, SD_idx)]
RealFitCenter1<- RealFit-mean(x2)-coef(mod)[1]
SDs=apply(BootstrapCoefs2, 2, sd)
sd1=RealFitCenter1-SDs
sd2=RealFitCenter1+SDs
cis=apply(BootstrapCoefs2, 2, quant.func)
MinimumYlim1<- min(cis-mean(x2)-coef(mod)[1])
MaximumYlim1<- max(cis-mean(x2)-coef(mod)[1])
cil1<-cis[1,]-mean(x2)-coef(mod)[1]
ciu1<-cis[2,]-mean(x2)-coef(mod)[1]
fitdf=data.frame(x=ShoreDistForPlotting, y=inv.logit(RealFitCenter1),
LCI=inv.logit(cil1), UCI=inv.logit(ciu1),
lsd=inv.logit(sd1), usd=inv.logit(sd2))
BootstrapCoefs2_invlogit=data.frame(vals=inv.logit(c(BootstrapCoefs2[,1],
BootstrapCoefs2[,2],
BootstrapCoefs2[,3])))
BootstrapCoefs2_invlogit$ShoreDist=as.character(sort(rep(c(5,10,15), length.out=nrow(BootstrapCoefs2_invlogit))))
Sd_P[[ii]]=ggplot(BootstrapCoefs2_invlogit, aes(x=ShoreDist, y=vals)) +
geom_boxplot() +
ggtitle(paste('Partial Plot of ShoreDist ', as.character(unique(data_sub$GroupId))))}
#######################################################
# Year as Factors #
#######################################################
Yr_idx=which(grepl("Year", colnames(BootstrapParameters)))
if(length(Yr_idx)>1){
x2<-model.matrix(test)[,Yr_idx]%*%coef(mod)[Yr_idx]
BootstrapCoefs2<- BootstrapParameters[,c(1, Yr_idx)]
RealFit<- coef(mod)[c(1, Yr_idx)]
RealFitCenter1<- RealFit-mean(x2)-coef(mod)[1]
SDs=apply(BootstrapCoefs2, 2, sd)
sd1=RealFitCenter1-SDs
sd2=RealFitCenter1+SDs
cis=apply(BootstrapCoefs2, 2, quant.func)
MinimumYlim1<- min(cis-mean(x2)-coef(mod)[1])
MaximumYlim1<- max(cis-mean(x2)-coef(mod)[1])
cil1<-cis[1,]-mean(x2)-coef(mod)[1]
ciu1<-cis[2,]-mean(x2)-coef(mod)[1]
fitdf=data.frame(x=YearsForPlotting, y=inv.logit(RealFitCenter1),
LCI=inv.logit(cil1), UCI=inv.logit(ciu1),
lsd=inv.logit(sd1), usd=inv.logit(sd2))
BootstrapCoefs2_invlogit=data.frame(vals=inv.logit(c(BootstrapCoefs2[,1],
BootstrapCoefs2[,2],
BootstrapCoefs2[,3])))
BootstrapCoefs2_invlogit$Year=as.character(sort(rep(YearsForPlotting, length.out=nrow(BootstrapCoefs2_invlogit))))
Yr_P[[ii]]=ggplot(BootstrapCoefs2_invlogit, aes(x=Year, y=vals)) +
geom_boxplot() +
ggtitle(paste('Partial Plot of Years '))}
rm(data_sub, mod, JdateForPlotting, x1, test, BootstrapCoefs, Basis, BootstrapFits, BootstrapParameters)
}
print(Yr_P)
