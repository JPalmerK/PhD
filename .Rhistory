dat$DistToShore= mm
dat$Slope=raster::extract(Slope, dat)
meta2$SlopeMap=raster::extract(Slope, meta2)
for(ii in 1:length(unique(meta2$RiverName))){
rname=as.character(unique(meta2$RiverName)[ii])
dat@data[, rname]=
distRhumb(river_locs[river_locs$Rivername==as.character(unique(meta2$RiverName)[ii]),], dat)
}
dat$DistToSalmonRun=apply(as.data.frame(dat@data[,5:10]), 1, FUN=min)
dat$RiverName=apply(as.data.frame(dat@data[,5:10]), 1,
FUN=function(x){unique(meta2$RiverName)[which.min(x)]})
RiverRanges=data.frame(aggregate(data=meta2, DistToSalmonRun~RiverName, FUN=range))
RiverRanges=merge(RiverRanges, river_locs,
all.x=TRUE, by.x=c('RiverName'), by.y='Rivername')
coordinates(RiverRanges)=c('lonDeg','LatDeg' )
proj4string(RiverRanges) <- crs.geo  # define projection system of our data
summary(RiverRanges)
featureRangeIDX=numeric()
for(ii in 1:length(unique(meta2$RiverName))){
## Create two circles, one for the minimum range one for the max, will interpolate
r1= RiverRanges$DistToSalmonRun[ii,1]-1000 #2km
r2= RiverRanges$DistToSalmonRun[ii,2]+1000 #2km
river_locs=RiverRanges[ii,]
river_locs_UTM=spTransform(river_locs, proj_UTM)
## Circles
circle1 <- SpatialCircle(river_locs_UTM, r1)
circle2 <- SpatialCircle(river_locs_UTM, r2)
# convert to wgs
circle1_wgs=spTransform(circle1, crs.geo)
circle2_wgs=spTransform(circle2, crs.geo)
plot(circle2_wgs, add=TRUE)
plot(circle1_wgs, add=TRUE)
inside.feature= which(!is.na(over(dat, as(circle2_wgs, "SpatialPolygons"))) &
is.na(over(dat, as(circle1_wgs, "SpatialPolygons"))))
featureRangeIDX=c(featureRangeIDX, inside.feature)
#
# # Plot checking
# points(dat[inside.river,], pch=16, col="red") #good
# points(meta2, pch=16, col="green") #good
# points(RiverRanges, pch=16, col="blue") #good
#
dat[-inside.feature, RiverRanges$RiverName[ii]]=NA
rm(circle1_wgs, circle2_wgs, circle1, circle2, r1, r2 )
}
featureRangeIDX=unique(featureRangeIDX)
points(dat[!is.na(dat$`Cromarty Firth`),], pch = 21, col = "Green",
bg = "green", cex = 1.3)
dat$DistToSalmonRun=rowSums(as.data.frame(dat@data[,5:10]), na.rm = TRUE)
rm(list=setdiff(ls(), c("dat", 'NorthSea', 'NorthSea_raster',
'proj_UTM', 'crs.geo', 'meta2', 'level_names')))
library(boot)            # for inv.logit
library(mgcv)
library(ggplot2)
library(lme4)
library(dplyr)           # for distinct function
library(geepack)         # To make the GEE's
library(splines)
library(RColorBrewer)
library(MuMIn)           # for QIC
library(MASS)            # for mvrnorm in boostrapping intervals
library(ROCR)            # to build the ROC curve
library(PresenceAbsence) # to build the confusion matrix
library(mvtnorm)         # for rmvnorm used in predictions/plotting
library(geosphere)
CalcAUC<-function(mod, data_sub, BinaryResponse_var){
pr_dat=as.data.frame(as.numeric(predict(mod, data_sub, type="response")))
pr_dat$labels=data_sub[, BinaryResponse_var]
colnames(pr_dat)[1]='predictions'
pred_dat=prediction(pr_dat$predictions, pr_dat$labels)
perf <- performance(pred_dat, measure="tpr", x.measure="fpr")
plot(perf, colorize=TRUE, print.cutoffs.at=c(0.1,0.2,0.3,0.4,0.5)) # to plot the ROC curve
y<-as.data.frame(perf@y.values)
x<-as.data.frame(perf@x.values)
fi <- atan(y/x) - pi/4                                             # to calculate the angle between the 45Â° line and the line joining the origin with the point (x;y) on the ROC curve
L <- sqrt(x^2+y^2)                                                 # to calculate the length of the line joining the origin to the point (x;y) on the ROC curve
d <- L*sin(fi)
alpha<-as.data.frame(perf@alpha.values)                            # the alpha values represent the corresponding cut-offs
Best_cutoff=alpha[which.max(unlist(d)),]
DATA<-matrix(0,nrow(data_sub),3)                                             # to build a matrix with 3 columns and n rows, where n is the dimension of the data set (here 919 - the number of rows can be checked with dim(dat))
DATA<-as.data.frame(DATA)
names(DATA)<-c("plotID","Observed","Predicted")
DATA$plotID<-1:nrow(data_sub)                                                # the first column is filled with an ID value that is unique for each row
DATA$Observed<-data_sub$BBOcc                                            # the second column reports the observed response (0s and 1s)
DATA$Predicted<-predict(mod,data_sub,type="response")                 # the third column reports the predictions
cmx(DATA, threshold = Best_cutoff)
# Area under the Curve
auc <- unlist(performance(pred_dat, measure="auc")@y.values)
# Proportion of the presences correctly identified
pres=prop.table(cmx(DATA, threshold = Best_cutoff))[1,1]
# Proportion of the absences correctly idenified
abs=prop.table(cmx(DATA, threshold = Best_cutoff))[2,2]
return(c(auc, pres, abs))
}
cbbPalette <- c("#000000", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
OccTable= read.csv('W:/KJP PHD/4-Bayesian Habitat Use/R Code/OccupancyTable_ThreePdets.csv')
meta=read.csv('W:/KJP PHD/Deployment Information/CPODs for Kaitlin.csv')
meta2=merge(meta2, distinct(meta[, c('UnitLoc', 'Depth_m')]), by='UnitLoc',all.x=TRUE)
OccTable$UnitLoc=factor(OccTable$UnitLoc, levels=level_names)
OccTable$DateUnitloc=as.factor(paste(OccTable$Date, OccTable$UnitLoc))
OccTable$ShoreDist=as.character(OccTable$ShoreDist)
OccTable$ShoreDist[OccTable$ShoreDist=="5"]='05'
OccTable$ShoreDist=as.factor(OccTable$ShoreDist)
level_names_group=c( "Lat", "Hel", "Cro",
"SpB", "Fra", "Cru",
"Sto", "Abr", "StA",
"Stb")
OccTable$GroupId=unlist(strsplit(as.character(OccTable$UnitLoc), split = "_"))[seq(1,(nrow(OccTable)*2)-1,2)]
OccTable$GroupId=factor(OccTable$GroupId, levels=level_names_group)
OccTable$Year=as.factor(OccTable$Year)
OccTable=merge(OccTable, meta2[,c('UnitLoc', 'DistToSalmonRun', 'RiverName', 'DistToShore', 'SlopeMap', 'Depth_m')],
by='UnitLoc', all.x = TRUE)
OccTable$RiverName=as.factor(OccTable$RiverName)
OccTable$JD_scale=scale(OccTable$JulienDay)
OccTable$FBOcc[is.na(OccTable$FBOcc)]=0
OccTable$BBOcc[is.na(OccTable$BBOcc)]=0
OccTable$UNKOcc[is.na(OccTable$UNKOcc)]=0
mm.bbtot=as.data.frame(aggregate(BBOcc~UnitLoc+Date, FUN=sum, data = OccTable))
colnames(mm.bbtot)[3]='BBTot'
mm.fbtot=as.data.frame(aggregate(FBOcc~UnitLoc+Date, FUN=sum, data = OccTable))
colnames(mm.fbtot)[3]='FBTot'
mm.unktot=as.data.frame(aggregate(UNKOcc~UnitLoc+Date, FUN=sum, data = OccTable))
colnames(mm.unktot)[3]='UNKTot'
mm=distinct(OccTable, Date, UnitLoc, JulienDay, GroupId, ShoreDist, SlopeMap,
Year, Month, RiverName, DistToSalmonRun, Depth_m, DistToShore)
mm.bb=distinct(subset(OccTable, BBOcc>0), Date, BBOcc, UnitLoc)
mm.fb=distinct(subset(OccTable, FBOcc>0), Date, FBOcc, UnitLoc)
mm.unk=distinct(subset(OccTable, UNKOcc>0), Date, UNKOcc, UnitLoc)
OccTable_daily=merge(mm, mm.bb, by = c('Date', 'UnitLoc'), all.x = TRUE)
OccTable_daily=merge(OccTable_daily, mm.fb, by = c('Date', 'UnitLoc'), all.x = TRUE)
OccTable_daily=merge(OccTable_daily, mm.unk, by = c('Date', 'UnitLoc'), all.x = TRUE)
OccTable_daily=merge(OccTable_daily, mm.bbtot, by = c('Date', 'UnitLoc'), all.x = TRUE)
OccTable_daily=merge(OccTable_daily, mm.fbtot, by = c('Date', 'UnitLoc'), all.x = TRUE)
OccTable_daily=merge(OccTable_daily, mm.unktot, by = c('Date', 'UnitLoc'), all.x = TRUE)
OccTable_daily[is.na(OccTable_daily)] <- 0
OccTable_daily$SpeciesOffset=OccTable_daily$BBOcc+OccTable_daily$FBOcc+OccTable_daily$UNKOcc
OccTable_daily$OccAll=ifelse(OccTable_daily$SpeciesOffset>=1,1,0)
OccTable_daily$SpeciesOffset[OccTable_daily$SpeciesOffset>1]=0.5
OccTable_daily$SpeciesOffset[OccTable_daily$SpeciesOffset==1 & OccTable_daily$BBOcc==1]=0.77
OccTable_daily$SpeciesOffset[OccTable_daily$SpeciesOffset==1 & OccTable_daily$FBOcc==1]=0.06
OccTable_daily$SpeciesOffset[OccTable_daily$SpeciesOffset==1 & OccTable_daily$UNKOcc==1]=0.5
OccTable_daily$BNDTotOffset=(OccTable_daily$BBTot*.77+OccTable_daily$FBTot*.06+OccTable_daily$UNKTot*.5)/
(OccTable_daily$BBTot+OccTable_daily$FBTot+OccTable_daily$UNKTot)
OccTable_daily$TotDet=(OccTable_daily$BBTot+OccTable_daily$FBTot+OccTable_daily$UNKTot)
OccTable_daily$BNDTotOffset[is.na(OccTable_daily$BNDTotOffset)]=0
OccTable_daily$dateunit=as.factor(paste(OccTable_daily$Date, OccTable_daily$UnitLoc))
OccTable_daily$ScaleJd=scale(OccTable_daily$JulienDay)
# Add season
OccTable_daily$Season=NA
OccTable_daily$Season[OccTable_daily$Month < 6]='Spring'
OccTable_daily$Season[OccTable_daily$Month > 8]='Autum'
OccTable_daily$Season[which(is.na(OccTable_daily$Season))]='Summer'
OccTable_daily$Season=as.factor(OccTable_daily$Season)
OccTable_daily$CentredMonth=OccTable_daily$Month-median(median(unique(OccTable_daily$Month)))
OccTable_daily$yearseason=as.factor(paste(OccTable_daily$Year, OccTable_daily$Season))
OccTable_daily$SeasonRiver=as.factor(paste(OccTable_daily$Season, OccTable_daily$RiverName))
rm(mm, mm.bb, mm.fb, mm.unk, mm.bbtot, mm.fbtot, mm.unktot)
##### Spatial Models##########################################################################
# Investagate correlation between covariates
cor(meta2$Depth_m, meta2$DistToSalmonRun, method='pearson') # correlation -0.4
cor(meta2$Depth_m, meta2$SlopeMap, method='pearson')
cor(meta2$Depth_m, meta2$DistToShore, method='pearson')
cor(meta2$DistToSalmonRun, meta2$SlopeMap, method='pearson')
cor(meta2$DistToSalmonRun, meta2$DistToShore, method='pearson')
cor(meta2$SlopeMap, meta2$DistToShore, method='pearson')
# All highly fucking correlated!
modlist_spatial=list()
modlist_spatial[[1]]= gamm(BNDTotOffset~s(Depth_m, bs='ts', k=3),
correlation=corAR1(form = ~1|dateunit),
family=binomial,
data=OccTable_daily)
modlist_spatial[[2]]= gamm(BNDTotOffset~s(SlopeMap, bs='ts', k=3),
correlation=corAR1(form = ~1|dateunit),
family=binomial,
data=OccTable_daily)
modlist_spatial[[3]]= gamm(BNDTotOffset~s(DistToShore, bs='ts', k=3),
correlation=corAR1(form = ~1|dateunit),
family=binomial,
data=OccTable_daily)
modlist_spatial[[4]]= gamm(BNDTotOffset~s(DistToSalmonRun, bs='ts', k=3),
correlation=corAR1(form = ~1|dateunit),
family=binomial,
data=OccTable_daily)
modlist_spatial[[5]]= gamm(BNDTotOffset~s(DistToSalmonRun, bs='ts', k=3)+s(Depth_m, bs='ts', k=3),
correlation=corAR1(form = ~1|dateunit),
family=binomial,
data=OccTable_daily)
modlist_spatial[[6]]= gamm(BNDTotOffset~s(Depth_m, bs='ts', k=3)+s(SlopeMap, bs='ts', k=3),
correlation=corAR1(form = ~1|dateunit),
family=binomial,
data=OccTable_daily)
modlist_spatial[[7]]= gamm(BNDTotOffset~s(SlopeMap, bs='ts', k=3, by=RiverName),
correlation=corAR1(form = ~1|dateunit),
family=binomial,
data=OccTable_daily)
modlist_spatial[[8]]= gamm(BNDTotOffset~s(DistToSalmonRun, bs='ts', k=3)+s(Depth_m, bs='ts', k=3) + Season,
correlation=corAR1(form = ~1|dateunit),
family=binomial,
data=OccTable_daily)
modlist_spatial[[9]]= gamm(BNDTotOffset~s(DistToSalmonRun, bs='ts', k=3) +
s(SlopeMap, bs='ts', k=3) + Season,
correlation=corAR1(form = ~1|dateunit),
family=binomial,
data=OccTable_daily)
modlist_spatial[[10]]= gamm(BNDTotOffset~s(DistToSalmonRun, bs='ts', k=3, by=Season)
+s(SlopeMap, bs='ts', k=3, by=Season) + Season,
correlation=corAR1(form = ~1|dateunit),
family=binomial,
data=OccTable_daily)
modlist_spatial[[11]]= gamm(BNDTotOffset~s(DistToSalmonRun, bs='ts', k=3)+
s(SlopeMap, bs='ts', k=3, by=Season) + Season,
correlation=corAR1(form = ~1|dateunit),
family=binomial,
data=OccTable_daily)
modlist_spatial[[12]]= gamm(BNDTotOffset~s(SlopeMap, bs='ts', k=3, by=Season) + Season,
correlation=corAR1(form = ~1|dateunit),
family=binomial,
data=OccTable_daily)
modlist_spatial[[13]]= gamm(BNDTotOffset~s(DistToSalmonRun, bs='ts', k=3, by=Season)
+s(DistToShore, bs='ts', k=3, by=Season) + Season,
correlation=corAR1(form = ~1|dateunit),
family=binomial,
data=OccTable_daily)
modlist_spatial[[14]]= gamm(BNDTotOffset~s(DistToSalmonRun, bs='ts', k=3)
+s(DistToShore, bs='ts', k=3, by=Season) + Season,
correlation=corAR1(form = ~1|dateunit),
family=binomial,
data=OccTable_daily)
lapply(modlist_spatial, AIC)
Preddat=data.frame(SlopeMap=dat$Slope,
Depth_m=dat$Depth.depth,
DistToSalmonRun=dat$DistToSalmonRun,
BNDTotOffset=rep(0, nrow(dat)),
DistToShore=dat$DistToShore,
Season='Summer')
dat1=dat
preds=predict(modlist_spatial[[13]], Preddat, type='response', se.fit=TRUE)
preds$UCI=preds$fit+(1.96*preds$se.fit)
preds$LCI=preds$fit-(1.96*preds$se.fit)
dat1=cbind(dat1, preds)
rbPal <- colorRampPalette(c('red','blue'))
dat1$Col <- rbPal(10)[as.numeric(cut(dat1$fit,breaks = 10))]
plot(dat1$Depth.lon, dat1$Depth.lat,
pch = 20,
col = dat1$Col, main=Preddat$Season[1])
dat1=dat[dat$DistToShore<max(meta2$DistToShore),]
preds=predict(modlist_spatial[[13]], Preddat, type='response', se.fit=TRUE)
preds$UCI=preds$fit+(1.96*preds$se.fit)
preds$LCI=preds$fit-(1.96*preds$se.fit)
dat1=cbind(dat1, preds)
dat1=dat[dat$DistToShore<max(meta2$DistToShore),]
Preddat=data.frame(SlopeMap=dat1$Slope,
Depth_m=dat1$Depth.depth,
DistToSalmonRun=dat1$DistToSalmonRun,
BNDTotOffset=rep(0, nrow(dat1)),
DistToShore=dat1$DistToShore,
Season='Summer')
preds=predict(modlist_spatial[[13]], Preddat, type='response', se.fit=TRUE)
preds$UCI=preds$fit+(1.96*preds$se.fit)
preds$LCI=preds$fit-(1.96*preds$se.fit)
dat1=cbind(dat1, preds)
dat1=dat[dat$DistToShore<max(meta2$DistToShore),]
Preddat=data.frame(SlopeMap=dat1$Slope,
Depth_m=dat1$Depth.depth,
DistToSalmonRun=dat1$DistToSalmonRun,
BNDTotOffset=rep(0, nrow(dat1)),
DistToShore=dat1$DistToShore,
Season='Summer')
preds=predict(modlist_spatial[[13]], Preddat, type='response', se.fit=TRUE)
preds$UCI=preds$fit+(1.96*preds$se.fit)
preds$LCI=preds$fit-(1.96*preds$se.fit)
dat1=cbind(dat1, preds)
rbPal <- colorRampPalette(c('red','blue'))
dat1$Col <- rbPal(10)[as.numeric(cut(dat1$fit,breaks = 10))]
plot(dat1$Depth.lon, dat1$Depth.lat,
pch = 20,
col = dat1$Col, main=Preddat$Season[1])
modlist_spatial[[14]]= gamm(BNDTotOffset~s(SlopeMap, bs='ts', k=3)
+s(DistToShore, bs='ts', k=3, by=Season) + Season,
correlation=corAR1(form = ~1|dateunit),
family=binomial,
data=OccTable_daily)
dat1=dat[dat$DistToShore<max(meta2$DistToShore),]
Preddat=data.frame(SlopeMap=dat1$Slope,
Depth_m=dat1$Depth.depth,
DistToSalmonRun=dat1$DistToSalmonRun,
BNDTotOffset=rep(0, nrow(dat1)),
DistToShore=dat1$DistToShore,
Season='Summer')
preds=predict(modlist_spatial[[14]], Preddat, type='response', se.fit=TRUE)
preds$UCI=preds$fit+(1.96*preds$se.fit)
preds$LCI=preds$fit-(1.96*preds$se.fit)
dat1=cbind(dat1, preds)
rbPal <- colorRampPalette(c('red','blue'))
dat1$Col <- rbPal(10)[as.numeric(cut(dat1$fit,breaks = 10))]
plot(dat1$Depth.lon, dat1$Depth.lat,
pch = 20,
col = dat1$Col, main=Preddat$Season[1])
lapply(modlist_spatial, AIC)
, by=Season
modlist_spatial[[15]]= gamm(BNDTotOffset~s(SlopeMap, bs='ts', k=3, by=Season)
+ s(DistToShore, bs='ts', k=3) + Season,
correlation=corAR1(form = ~1|dateunit),
family=binomial,
data=OccTable_daily)
unlist(lapply(modlist_spatial, AIC))
dat1=dat[dat$DistToShore<max(meta2$DistToShore),]
Preddat=data.frame(SlopeMap=dat1$Slope,
Depth_m=dat1$Depth.depth,
DistToSalmonRun=dat1$DistToSalmonRun,
BNDTotOffset=rep(0, nrow(dat1)),
DistToShore=dat1$DistToShore,
Season='Summer')
preds=predict(modlist_spatial[[14]], Preddat, type='response', se.fit=TRUE)
preds$UCI=preds$fit+(1.96*preds$se.fit)
preds$LCI=preds$fit-(1.96*preds$se.fit)
dat1=cbind(dat1, preds)
rbPal <- colorRampPalette(c('red','blue'))
dat1$Col <- rbPal(10)[as.numeric(cut(dat1$fit,breaks = 10))]
plot(dat1$Depth.lon, dat1$Depth.lat,
pch = 20,
col = dat1$Col, main=Preddat$Season[1])
dat1=dat[dat$DistToShore<max(meta2$DistToShore),]
Preddat=data.frame(SlopeMap=dat1$Slope,
Depth_m=dat1$Depth.depth,
DistToSalmonRun=dat1$DistToSalmonRun,
BNDTotOffset=rep(0, nrow(dat1)),
DistToShore=dat1$DistToShore,
Season='Summer')
preds=predict(modlist_spatial[[15]], Preddat, type='response', se.fit=TRUE)
preds$UCI=preds$fit+(1.96*preds$se.fit)
preds$LCI=preds$fit-(1.96*preds$se.fit)
dat1=cbind(dat1, preds)
rbPal <- colorRampPalette(c('red','blue'))
dat1$Col <- rbPal(10)[as.numeric(cut(dat1$fit,breaks = 10))]
plot(dat1$Depth.lon, dat1$Depth.lat,
pch = 20,
col = dat1$Col, main=Preddat$Season[1])
dat1=dat[dat$DistToShore<(max(meta2$DistToShore)+2000),]
Preddat=data.frame(SlopeMap=dat1$Slope,
Depth_m=dat1$Depth.depth,
DistToSalmonRun=dat1$DistToSalmonRun,
BNDTotOffset=rep(0, nrow(dat1)),
DistToShore=dat1$DistToShore,
Season='Summer')
dat1=dat[dat$DistToShore<(max(meta2$DistToShore)+2000)),]
dat1=dat[dat$DistToShore<(max(meta2$DistToShore)+2000),]
Preddat=data.frame(SlopeMap=dat1$Slope,
Depth_m=dat1$Depth.depth,
DistToSalmonRun=dat1$DistToSalmonRun,
BNDTotOffset=rep(0, nrow(dat1)),
DistToShore=dat1$DistToShore,
Season='Summer')
preds=predict(modlist_spatial[[15]], Preddat, type='response', se.fit=TRUE)
preds$UCI=preds$fit+(1.96*preds$se.fit)
preds$LCI=preds$fit-(1.96*preds$se.fit)
dat1=cbind(dat1, preds)
rbPal <- colorRampPalette(c('red','blue'))
dat1$Col <- rbPal(10)[as.numeric(cut(dat1$fit,breaks = 10))]
plot(dat1$Depth.lon, dat1$Depth.lat,
pch = 20,
col = dat1$Col, main=Preddat$Season[1])
dat1=dat[dat$DistToShore<(max(meta2$DistToShore)+2000),]
Preddat=data.frame(SlopeMap=dat1$Slope,
Depth_m=dat1$Depth.depth,
DistToSalmonRun=dat1$DistToSalmonRun,
BNDTotOffset=rep(0, nrow(dat1)),
DistToShore=dat1$DistToShore,
Season='Autumn')
preds=predict(modlist_spatial[[15]], Preddat, type='response', se.fit=TRUE)
preds$UCI=preds$fit+(1.96*preds$se.fit)
preds$LCI=preds$fit-(1.96*preds$se.fit)
dat1=cbind(dat1, preds)
rbPal <- colorRampPalette(c('red','blue'))
dat1$Col <- rbPal(10)[as.numeric(cut(dat1$fit,breaks = 10))]
plot(dat1$Depth.lon, dat1$Depth.lat,
pch = 20,
col = dat1$Col, main=Preddat$Season[1])
Preddat=data.frame(SlopeMap=dat1$Slope,
Depth_m=dat1$Depth.depth,
DistToSalmonRun=dat1$DistToSalmonRun,
BNDTotOffset=rep(0, nrow(dat1)),
DistToShore=dat1$DistToShore,
Season='Autum')
preds=predict(modlist_spatial[[15]], Preddat, type='response', se.fit=TRUE)
preds$UCI=preds$fit+(1.96*preds$se.fit)
preds$LCI=preds$fit-(1.96*preds$se.fit)
dat1=cbind(dat1, preds)
rbPal <- colorRampPalette(c('red','blue'))
dat1$Col <- rbPal(10)[as.numeric(cut(dat1$fit,breaks = 10))]
plot(dat1$Depth.lon, dat1$Depth.lat,
pch = 20,
col = dat1$Col, main=Preddat$Season[1])
dat1=dat[dat$DistToShore<(max(meta2$DistToShore)+2000),]
Preddat=data.frame(SlopeMap=dat1$Slope,
Depth_m=dat1$Depth.depth,
DistToSalmonRun=dat1$DistToSalmonRun,
BNDTotOffset=rep(0, nrow(dat1)),
DistToShore=dat1$DistToShore,
Season='Autum')
preds=predict(modlist_spatial[[15]], Preddat, type='response', se.fit=TRUE)
preds$UCI=preds$fit+(1.96*preds$se.fit)
preds$LCI=preds$fit-(1.96*preds$se.fit)
dat1=cbind(dat1, preds)
rbPal <- colorRampPalette(c('red','blue'))
dat1$Col <- rbPal(10)[as.numeric(cut(dat1$fit,breaks = 10))]
plot(dat1$Depth.lon, dat1$Depth.lat,
pch = 20,
col = dat1$Col, main=Preddat$Season[1])
rbPal <- colorRampPalette(c('red','blue'))
dat1$Col <- rbPal(10)[as.numeric(cut(dat1$fit,breaks = 10))]
plot(dat1$Depth.lon, dat1$Depth.lat,
pch = 20,
col = dat1$Col, main=Preddat$Season[1])
dat1=dat[dat$DistToShore<(max(meta2$DistToShore)+2000),]
Preddat=data.frame(SlopeMap=dat1$Slope,
Depth_m=dat1$Depth.depth,
DistToSalmonRun=dat1$DistToSalmonRun,
BNDTotOffset=rep(0, nrow(dat1)),
DistToShore=dat1$DistToShore,
Season='Spring')
preds=predict(modlist_spatial[[15]], Preddat, type='response', se.fit=TRUE)
preds$UCI=preds$fit+(1.96*preds$se.fit)
preds$LCI=preds$fit-(1.96*preds$se.fit)
dat1=cbind(dat1, preds)
rbPal <- colorRampPalette(c('red','blue'))
dat1$Col <- rbPal(10)[as.numeric(cut(dat1$fit,breaks = 10))]
plot(dat1$Depth.lon, dat1$Depth.lat,
pch = 20,
col = dat1$Col, main=Preddat$Season[1])
modlist_spatial[[16]]= gamm(BNDTotOffset~s(SlopeMap, bs='ts', by=Season)
+ s(DistToShore, bs='ts') + Season,
correlation=corAR1(form = ~1|dateunit),
family=binomial,
data=OccTable_daily)
modlist_spatial[[16]]= gamm(BNDTotOffset~s(SlopeMap, bs='ts', by=Season)
+ s(DistToShore, bs='ts') + Season,
correlation=corAR1(form = ~1|UnitLoc),
family=binomial,
data=OccTable_daily)
dat1=dat[dat$DistToShore<(max(meta2$DistToShore)+2000),]
Preddat=data.frame(SlopeMap=dat1$Slope,
Depth_m=dat1$Depth.depth,
DistToSalmonRun=dat1$DistToSalmonRun,
BNDTotOffset=rep(0, nrow(dat1)),
DistToShore=dat1$DistToShore,
Season='Spring')
preds=predict(modlist_spatial[[16]], Preddat, type='response', se.fit=TRUE)
preds$UCI=preds$fit+(1.96*preds$se.fit)
preds$LCI=preds$fit-(1.96*preds$se.fit)
dat1=cbind(dat1, preds)
rbPal <- colorRampPalette(c('red','blue'))
dat1$Col <- rbPal(10)[as.numeric(cut(dat1$fit,breaks = 10))]
plot(dat1$Depth.lon, dat1$Depth.lat,
pch = 20,
col = dat1$Col, main=Preddat$Season[1])
modlist_spatial[[16]]= gamm(BNDTotOffset~s(SlopeMap, bs='ts', k=3, by=Season)
+ s(DistToShore, bs='ts', k=3) + Season,
correlation=corAR1(form = ~1|UnitLoc),
family=binomial,
data=OccTable_daily)
lapply(modlist_spatial, AIC)
dat1=dat[dat$DistToShore<(max(meta2$DistToShore)+2000),]
Preddat=data.frame(SlopeMap=dat1$Slope,
Depth_m=dat1$Depth.depth,
DistToSalmonRun=dat1$DistToSalmonRun,
BNDTotOffset=rep(0, nrow(dat1)),
DistToShore=dat1$DistToShore,
Season='Spring')
preds=predict(modlist_spatial[[16]], Preddat, type='response', se.fit=TRUE)
preds$UCI=preds$fit+(1.96*preds$se.fit)
preds$LCI=preds$fit-(1.96*preds$se.fit)
dat1=cbind(dat1, preds)
rbPal <- colorRampPalette(c('red','blue'))
dat1$Col <- rbPal(10)[as.numeric(cut(dat1$fit,breaks = 10))]
plot(dat1$Depth.lon, dat1$Depth.lat,
pch = 20,
col = dat1$Col, main=Preddat$Season[1])
plot(dat1$Depth.lon, dat1$Depth.lat,
pch = 20,
col = dat1$Col, main=Preddat$Season[1])
dat1=dat[dat$DistToShore<(max(meta2$DistToShore)+2000),]
Preddat=data.frame(SlopeMap=dat1$Slope,
Depth_m=dat1$Depth.depth,
DistToSalmonRun=dat1$DistToSalmonRun,
BNDTotOffset=rep(0, nrow(dat1)),
DistToShore=dat1$DistToShore,
Season='Autum')
preds=predict(modlist_spatial[[16]], Preddat, type='response', se.fit=TRUE)
preds$UCI=preds$fit+(1.96*preds$se.fit)
preds$LCI=preds$fit-(1.96*preds$se.fit)
dat1=cbind(dat1, preds)
rbPal <- colorRampPalette(c('red','blue'))
dat1$Col <- rbPal(10)[as.numeric(cut(dat1$fit,breaks = 10))]
plot(dat1$Depth.lon, dat1$Depth.lat,
pch = 20,
col = dat1$Col, main=Preddat$Season[1])
dat1=dat[dat$DistToShore<(max(meta2$DistToShore)+2000),]
Preddat=data.frame(SlopeMap=dat1$Slope,
Depth_m=dat1$Depth.depth,
DistToSalmonRun=dat1$DistToSalmonRun,
BNDTotOffset=rep(0, nrow(dat1)),
DistToShore=dat1$DistToShore,
Season='Summer')
preds=predict(modlist_spatial[[16]], Preddat, type='response', se.fit=TRUE)
preds$UCI=preds$fit+(1.96*preds$se.fit)
preds$LCI=preds$fit-(1.96*preds$se.fit)
dat1=cbind(dat1, preds)
rbPal <- colorRampPalette(c('red','blue'))
dat1$Col <- rbPal(10)[as.numeric(cut(dat1$fit,breaks = 10))]
plot(dat1$Depth.lon, dat1$Depth.lat,
pch = 20,
col = dat1$Col, main=Preddat$Season[1])
